modbus_controller:
 - id: ${evse_name}_modbus_controller
   address: ${evse_modbus_address}
   modbus_id: ${evse_modbus_id}
   command_throttle: ${evse_modbus_throttle}
   setup_priority: -10
   update_interval: ${evse_update_interval}

output:
  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    id: ${evse_name}_output 
    address: 109
    register_type: holding
    value_type: U_WORD
    # multiply: 1000
    
sensor:

  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_cable_function
    id: ${evse_name}_cable_function
    address: 113
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0
    icon: mdi:cable-data
    #skip_updates: 1
    # register_count: 6
    
  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_software_version
    id: ${evse_name}_software_version
    address: 140
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0
    icon: mdi:numeric
    #skip_updates: 1
    register_count: 6
    
  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_current
    id: ${evse_name}_current
    address: 146
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 1
    unit_of_measurement: 'A'
    icon: mdi:current-ac
    skip_updates: 1
    register_count: 6
    filters:
      - multiply:  0.01
    
  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_pwm
    id: ${evse_name}_pwm
    address: 152
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0
    icon: mdi:gauge
    skip_updates: 1
    filters:
      - multiply:  0.01
    
  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_temperature
    id: ${evse_name}_temperature
    address: 157
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0
    unit_of_measurement: 'Â°C'
    icon: mdi:thermometer
    skip_updates: 1  
    

text_sensor:

  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_rcmu
    id: ${evse_name}_rcmu_text
    address: 143
    register_type: holding
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("Not selected");
        case 1: return std::string("Normal operation");
        case 2: return std::string("Self-check failed");
        case 3: return std::string("Leakage in charging circuit");
        default: return std::string("Unknown");
      }
      return x;
      
  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_rfid
    id: ${evse_name}_rfid_text
    address: 144
    register_type: holding
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("Not selected");
        case 1: return std::string("IC card not operating");
        case 2: return std::string("IC card closed");
        case 3: return std::string("IC card open");
        default: return std::string("Unknown");
      }
      return x;

  - platform: modbus_controller
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_lock
    id: ${evse_name}__lock_text
    address: 145
    register_type: holding
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("Not selected");
        case 1: return std::string("Locked");
        case 2: return std::string("Unlocked");
        case 3: return std::string("Fault");
        default: return std::string("Unknown");
      }
      return x;      
  
select:

  - platform: modbus_controller
    use_write_multiple: true
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_startstop_control
    id: ${evse_name}_startstop_control_select
    address: 89
    value_type: U_WORD
    optionsmap:
      "Invalid": 0
      "Start": 1
      "Stop": 2

  - platform: modbus_controller
    use_write_multiple: true
    modbus_controller_id: ${evse_name}_modbus_controller
    name: ${name}_${evse_name}_rfid_control
    id: ${evse_name}_rfid_control_select
    address: 140
    value_type: U_WORD
    optionsmap:
      "Disable": 0
      "Enable": 1

  # - platform: modbus_controller
    # use_write_multiple: true
    # modbus_controller_id: ${evse_name}_modbus_controller
    # name: ${name}_${evse_name}_rcmu
    # id: ${evse_name}_rcmu_select
    # address: 143
    # value_type: U_WORD
    # optionsmap:
      # "Not selected": 0
      # "Normal operation": 1
      # "Self-check failed": 2
      # "Leakage in charging circuit": 3

  # - platform: modbus_controller
    # use_write_multiple: true
    # modbus_controller_id: ${evse_name}_modbus_controller
    # name: ${name}_${evse_name}_rfid
    # id: ${evse_name}_rfid_select
    # address: 144
    # value_type: U_WORD
    # optionsmap:
      # "Not selected": 0
      # "IC card not operating": 1
      # "IC card closed": 2
      # "IC card open": 3
      
  # - platform: modbus_controller
    # use_write_multiple: true
    # modbus_controller_id: ${evse_name}_modbus_controller
    # name: ${name}_${evse_name}_lock
    # id: ${evse_name}_lock_select
    # address: 145
    # value_type: U_WORD
    # optionsmap:
      # "Not selected": 0
      # "Locked": 1
      # "Unlocked": 2
      # "Fault": 3      