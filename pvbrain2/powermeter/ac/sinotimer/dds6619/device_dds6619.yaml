globals:
  - id: ${powermeter_name}_energy_yesterday_global
    type: float
    restore_value: yes
    
time:
  - platform: homeassistant #sntp
    id: !extend my_time
    on_time:
      - seconds: ${my_second}
        minutes: ${my_minute}
        hours: ${my_hours}
        then:  
          - globals.set:
              id: ${powermeter_name}_energy_yesterday_global
              value: !lambda return ( id(${powermeter_name}_energy_yesterday_global) =  float( id(${powermeter_name}_energy_today).state) );


modbus_controller:
 - id: ${powermeter_name}_modbus_controller
   address: ${powermeter_modbus_address}
   modbus_id: ${powermeter_modbus_id}
   command_throttle: ${powermeter_command_throttle}
   setup_priority: -10
   update_interval: ${powermeter_update_interval}
   
sensor:

  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # name: ${name}_${powermeter_name}_databaud
    # id: ${powermeter_name}_databaud
    # address: 0x0000
    # register_type: holding #read #holding
    # value_type: FP32 #U_DWORD_R 
    # accuracy_decimals: 0
    # state_class: 'measurement'
    # device_class: ''
    # #unit_of_measurement: ''
    # # device_class: 'voltage'
    # icon: mdi:numeric
    
  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # name: ${name}_${powermeter_name}_parity
    # id: ${powermeter_name}_parity
    # address: 0x0002  
    # register_type: holding #read #holding
    # value_type: FP32 #U_DWORD_R 
    # accuracy_decimals: 0
    # state_class: 'measurement'
    # device_class: ''
    # #unit_of_measurement: ''
    # # device_class: 'voltage'
    # icon: mdi:numeric
    

  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # name: ${name}_${powermeter_name}_modbus_address
    # id: ${powermeter_name}_modbus_address
    # address: 0x0008  
    # register_type: holding #read #holding
    # value_type: FP32 #U_DWORD_R 
    # accuracy_decimals: 0
    # state_class: 'measurement'
    # device_class: ''
    # #unit_of_measurement: ''
    # # device_class: 'voltage'
    # icon: mdi:numeric
    

     
  - platform: modbus_controller
    modbus_controller_id: ${powermeter_name}_modbus_controller
    name: ${name}_${powermeter_name}_voltage
    id: ${powermeter_name}_voltage
    address: 0x0000  
    register_type: read #read #holding
    value_type: U_WORD 
    accuracy_decimals: 1
    unit_of_measurement: 'V'
    device_class: 'voltage'
    icon: mdi:sine-wave
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: ${powermeter_name}_modbus_controller
    name: ${name}_${powermeter_name}_current
    id: ${powermeter_name}_current
    address: 0x0003 
    register_type: read #holding
    value_type: S_WORD
    accuracy_decimals: 1
    unit_of_measurement: 'A'
    device_class: 'current'
    icon: mdi:current-ac
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: ${powermeter_name}_modbus_controller
    name: ${name}_${powermeter_name}_power
    id: ${powermeter_name}_power
    address: 0x0008
    register_type: read #holding
    value_type: S_WORD #S_DWORD_R
    accuracy_decimals: 1
    unit_of_measurement: 'W'
    device_class: 'power'
    icon: mdi:power
    # filters:
      # - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: ${powermeter_name}_modbus_controller
    name: ${name}_${powermeter_name}_power_factor
    id: ${powermeter_name}_power_factor
    address: 0x0014
    register_type: read #holding
    value_type: U_WORD #U_DWORD_R
    accuracy_decimals: 2
    #unit_of_measurement: 'W'
    device_class: 'power_factor'
    icon: mdi:numeric
    filters:
      - multiply: 0.00001

  - platform: modbus_controller
    modbus_controller_id: ${powermeter_name}_modbus_controller
    name: ${name}_${powermeter_name}_frequency
    id: ${powermeter_name}_frequency
    address: 0x001A
    register_type: read #holding
    value_type: U_WORD #U_DWORD_R
    accuracy_decimals: 2
    unit_of_measurement: 'Hz'
    device_class: 'frequency'
    icon: mdi:sine-wave
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: ${powermeter_name}_modbus_controller
    name: ${name}_${powermeter_name}_energy_total
    id: ${powermeter_name}_energy_total
    address: 0x001D
    register_type: read #holding
    value_type: U_DWORD
    accuracy_decimals: 1
    unit_of_measurement: 'kWh'
    device_class: 'energy'
    icon: mdi:counter
    filters:
      - multiply: 0.01
      
  - platform: total_daily_energy
    name: ${name}_${powermeter_name}_energy_today
    id: ${powermeter_name}_energy_today
    power_id: ${powermeter_name}_power
    unit_of_measurement: 'kWh'
    accuracy_decimals: 1
    method: right
    restore: true
    filters:
        # Multiplication factor from W to kW is 0.001
      - multiply: 0.001
    icon: mdi:counter
    
  - platform: template
    name: ${name}_${powermeter_name}_energy_yesterday
    id: ${powermeter_name}_energy_yesterday
    unit_of_measurement: 'kWh'
    accuracy_decimals: 1
    icon: mdi:counter
    update_interval: ${powermeter_template_update}
    lambda: |-
      return (id(${powermeter_name}_energy_yesterday).state = id(${powermeter_name}_energy_yesterday_global));



  # - platform: integration
    # name: ${name}_${powermeter_name}_energy_total
    # id: ${powermeter_name}_energy_total
    # sensor: ${powermeter_name}_power
    # time_unit: h
    # restore: true
    # state_class: total_increasing
    # device_class: energy
    # unit_of_measurement: 'kWh'
    # icon: mdi:counter
    # accuracy_decimals: 1
    # filters:
        # # Multiplication factor from W to kW is 0.001
      # - multiply: 0.001      

# text_sensor:

  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # register_type: read
    # address: 0x0000
    # register_count: 2
    # response_size: 4
    # raw_encode: HEXBYTES
    # name: ${name}_${powermeter_name}_voltage_text
    # lambda: |-
      # uint16_t reg1 = modbus_controller::word_from_hex_str(x, 0);
      # uint16_t reg2 = modbus_controller::word_from_hex_str(x, 1);
      
      # // Extraire les 4 octets
      # uint8_t byte1 = (reg1 >> 8) & 0xFF;
      # uint8_t byte2 = reg1 & 0xFF;
      # uint8_t byte3 = (reg2 >> 8) & 0xFF;
      # uint8_t byte4 = reg2 & 0xFF;
      
      # // Créer la chaîne
      # char buffer[20];
      # sprintf(buffer, "%02X %02X %02X %02X", byte1, byte2, byte3, byte4);
      # return {buffer};
      
  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # register_type: read
    # address: 0x002A
    # register_count: 2
    # response_size: 4
    # raw_encode: HEXBYTES
    # name: ${name}_${powermeter_name}_power_factor_text
    # lambda: |-
      # uint16_t reg1 = modbus_controller::word_from_hex_str(x, 0);
      # uint16_t reg2 = modbus_controller::word_from_hex_str(x, 1);
      
      # // Extraire les 4 octets
      # uint8_t byte1 = (reg1 >> 8) & 0xFF;
      # uint8_t byte2 = reg1 & 0xFF;
      # uint8_t byte3 = (reg2 >> 8) & 0xFF;
      # uint8_t byte4 = reg2 & 0xFF;
      
      # // Créer la chaîne
      # char buffer[20];
      # sprintf(buffer, "%02X %02X %02X %02X", byte1, byte2, byte3, byte4);
      # return {buffer};

  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # register_type: read
    # address: 0x0036
    # register_count: 2
    # response_size: 4
    # raw_encode: HEXBYTES
    # name: ${name}_${powermeter_name}_frequency_text
    # lambda: |-
      # uint16_t reg1 = modbus_controller::word_from_hex_str(x, 0);
      # uint16_t reg2 = modbus_controller::word_from_hex_str(x, 1);
      
      # // Extraire les 4 octets
      # uint8_t byte1 = (reg1 >> 8) & 0xFF;
      # uint8_t byte2 = reg1 & 0xFF;
      # uint8_t byte3 = (reg2 >> 8) & 0xFF;
      # uint8_t byte4 = reg2 & 0xFF;
      
      # // Créer la chaîne
      # char buffer[20];
      # sprintf(buffer, "%02X %02X %02X %02X", byte1, byte2, byte3, byte4);
      # return {buffer};      


  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # register_type: holding
    # address: 0x0000 #0x0036
    # register_count: 2
    # response_size: 4
    # raw_encode: HEXBYTES
    # name: ${name}_${powermeter_name}_databaud_text
    # lambda: |-
      # uint16_t reg1 = modbus_controller::word_from_hex_str(x, 0);
      # uint16_t reg2 = modbus_controller::word_from_hex_str(x, 1);
      
      # // Extraire les 4 octets
      # uint8_t byte1 = (reg1 >> 8) & 0xFF;
      # uint8_t byte2 = reg1 & 0xFF;
      # uint8_t byte3 = (reg2 >> 8) & 0xFF;
      # uint8_t byte4 = reg2 & 0xFF;
      
      # // Créer la chaîne
      # char buffer[20];
      # sprintf(buffer, "%02X %02X %02X %02X", byte1, byte2, byte3, byte4);
      # return {buffer};
      
  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # register_type: holding
    # address: 0x0002 #0x0036
    # register_count: 2
    # response_size: 4
    # raw_encode: HEXBYTES
    # name: ${name}_${powermeter_name}_parity_text
    # lambda: |-
      # uint16_t reg1 = modbus_controller::word_from_hex_str(x, 0);
      # uint16_t reg2 = modbus_controller::word_from_hex_str(x, 1);
      
      # // Extraire les 4 octets
      # uint8_t byte1 = (reg1 >> 8) & 0xFF;
      # uint8_t byte2 = reg1 & 0xFF;
      # uint8_t byte3 = (reg2 >> 8) & 0xFF;
      # uint8_t byte4 = reg2 & 0xFF;
      
      # // Créer la chaîne
      # char buffer[20];
      # sprintf(buffer, "%02X %02X %02X %02X", byte1, byte2, byte3, byte4);
      # return {buffer};    


  # - platform: modbus_controller
    # modbus_controller_id: ${powermeter_name}_modbus_controller
    # register_type: holding
    # address: 0x0008 #0x0036
    # register_count: 2
    # response_size: 4
    # raw_encode: HEXBYTES
    # name: ${name}_${powermeter_name}_modbus_address_text
    # lambda: |-
      # uint16_t reg1 = modbus_controller::word_from_hex_str(x, 0);
      # uint16_t reg2 = modbus_controller::word_from_hex_str(x, 1);
      
      # // Extraire les 4 octets
      # uint8_t byte1 = (reg1 >> 8) & 0xFF;
      # uint8_t byte2 = reg1 & 0xFF;
      # uint8_t byte3 = (reg2 >> 8) & 0xFF;
      # uint8_t byte4 = reg2 & 0xFF;
      
      # // Créer la chaîne
      # char buffer[20];
      # sprintf(buffer, "%02X %02X %02X %02X", byte1, byte2, byte3, byte4);
      # return {buffer};      